"""
Эта задача является дополнительной, то есть ее решение не принесет вам баллы.
Задача сложнее остальных задач из этого раздела, и идея ее решения выходит за рамки простого понимания регулярных выражений как средства задания шаблона строки.
Мы решили включить данную задачу в урок, чтобы показать, что регулярным выражением можно проверить не только "внешний вид" строки, но и заложенный в ней смысл.


Вам дана последовательность строк.
Выведите строки, содержащие двоичную запись числа, кратного 3.

Двоичной записью числа называется его запись в двоичной системе счисления.

Примечание 2:
﻿Данная задача очень просто может быть решена приведением строки к целому числу и проверке остатка от деления на три, но мы все же предлагаем вам решить ее, не используя приведение к числу.
Sample Input:
0
10010
00101
01001
Not a number
1 1
0 0
Sample Output:
0
10010
01001
"""

import sys
import re

for line in sys.stdin:
  line = line.strip()
  line_2 = line
  line_2 = re.sub(r'n|p|\.', r'2', line_2) # Удалил служебные символы.
  Line_2 = re.sub(r'(\w\w)', r'\1.', line_2) # Разбил на пары битов.
  Line_2 = re.sub(r'(^[01]|\.[01])\b', r'\g<1>0', line_2) # Сделал количество символов четным.
  Line_2 = re.sub(r'11', r'00', line_2) # Разница четных и нечетных байтов равна нулю
  Line_2 = re.sub(r'01', r'n', line_2) # Разница четных и нечетных байтов  отрицательна
  Line_2 = re.sub(r'10', r'p', line_2) #  Разница четных и нечетных байтов положительна
  Line_2 = re.sub(r'(\.|0*)*', r'', line_2) # Убрал разделители и т.д.
  while re.match(r'.*np|.*pn', line_2):
    line_2= re.sub(r'np|pn', r'', line_2) #   Суммирую биты
  line_2 = re.sub(r'n', r'p', line_2) #   Упростил
  line_2= re.sub(r'ppp', r'', line_2) #   Сократил цифры кратные 3
  if line_2 == r'':
    print(line)
